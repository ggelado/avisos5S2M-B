<style>
  /* Fix para los marcadores de Leaflet */
  .markdown-body .leaflet-marker-icon,
  .markdown-body .leaflet-marker-shadow {
    background-color: transparent !important;
  }
</style>
<section class="container-lg my-4">

  <div id="status" class="text-small color-fg-muted mb-2">
  </div>

  <div id="aviso-atasco" class="text-small color-fg-muted mb-2" style="display: none;">
  </div>

  <div class="Box">
    <div class="Box-body p-0">
      <ul id="arrivals" class="list-style-none m-0"></ul>
    </div>
  </div>

  <div id="link-atascos" style="text-align:center; font-size:0.75em; margin-top:4px; display:none;">
  </div>
</section>
<script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"></script>

<script>
  async function mostrarLinkAtascos() {
    const contenedor = document.getElementById('link-atascos');
    if (!contenedor) return;

    try {
      const res = await fetch('https://notifierpushrss.onrender.com/api/poblados');
      if (!res.ok) throw new Error(`HTTP status ${res.status}`);
      const data = await res.json();

      if (data.hayAtascos) {
        // Mostrar enlace solo si hay atascos
        contenedor.innerHTML = `<a href="/avisos5S2M-B/poblados.html">
        Estado del tráfico en Av. Poblados
      </a>`;
        contenedor.style.display = 'block';
      } else {
        contenedor.style.display = 'none';
        contenedor.innerHTML = '';
      }

    } catch (err) {
      contenedor.style.display = 'none';
    }
  }

  // Ejecutar al cargar la página y refrescar cada 2 minutos
  document.addEventListener('DOMContentLoaded', () => {
    mostrarLinkAtascos();
    setInterval(mostrarLinkAtascos, 120000);
  });
</script>

<script>
  // --- Servicios lanzadera (horario fijo, L-V) ---
  const SHUTTLES = [
    {
      line: "LZ-CIU",
      destination: "Campus de Montegancedo → Ciudad Universitaria (PROGRAMADO. SOLO DÍAS LECTIVOS)",
      times: ["10:00", "11:00", "12:00", "13:00", "14:00"]
    },
    {
      line: "LZ-BARR",
      destination: "Campus de Montegancedo →  El Barrial – Centro Comercial Pozuelo (PROGRAMADO, SOLO DÍAS LECTIVOS)",
      times: ["08:35", "09:15", "10:00"]
    }
  ];

  (() => {
    // --- Paradas de referencia por línea (para el endpoint locations) ---
    const LINE_STOPS = {
      "8__571___": "08771",
      "8__573___": "08771",
      "8_N_905___": "08771",
      "8__591___": "08411",
      "8__865___": "17573"
    };

    const SOURCES = [
      { url: "https://api.madridtransporte.com/stops/bus/08771/times", lines: ["571", "573", "N905"] },
      { url: "https://api.madridtransporte.com/stops/bus/08411/times", lines: ["591"] },
      { url: "https://api.madridtransporte.com/stops/bus/17573/times", lines: ["865"] },
      {
        url: "https://api.madridtransporte.com/stops/tram/29/times",
        lines: null,
        isTram: true // marca que es metro ligero
      }
    ];

    const arrivalsEl = document.getElementById("arrivals");
    const statusEl = document.getElementById("status");
    const maps = {}; // lineCode -> { map, markers }

    function minutesFromNow(ts) {
      return Math.max(0, Math.round((ts - Date.now()) / 60000));
    }

    function isWeekday(date = new Date()) {
      const d = date.getDay();
      return d >= 1 && d <= 5; // L-V
    }


    function minutesUntilTodayTime(hhmm) {
      const [h, m] = hhmm.split(":").map(Number);
      const now = new Date();
      const t = new Date();
      t.setHours(h, m, 0, 0);
      return Math.round((t - now) / 60000);
    }


    function uniqueSorted(arr) {
      return [...new Set(arr)].sort((a, b) => a - b);
    }

    // --- Cargar próximas llegadas ---
    async function loadArrivals() {
      const results = [];

      for (const source of SOURCES) {
        try {
          const res = await fetch(source.url);
          const data = await res.json();

          // --- Metro Ligero ---
          if (source.isTram) {
            for (const arrival of data.arrives || []) {
              if (arrival.direction !== 2) continue;
              const times = uniqueSorted(arrival.estimatedArrives || []);
              times.forEach(ts => {
                results.push({
                  line: "ML3",
                  lineCode: arrival.lineCode,
                  destination: arrival.destination,
                  minutes: minutesFromNow(ts),
                  isTram: true
                });
              });
            }
            continue;
          }

          // --- Buses ---
          for (const arrival of data.arrives || []) {
            if (source.lines && !source.lines.includes(arrival.line)) continue;
            const times = uniqueSorted(arrival.estimatedArrives || []);
            times.forEach(ts => {
              results.push({
                line: arrival.line,
                lineCode: arrival.lineCode,
                destination: arrival.destination,
                minutes: minutesFromNow(ts),
                isTram: false
              });
            });
          }
        } catch (e) {
        }
      }

      // --- Lanzaderas programadas ---
      if (isWeekday()) {
        SHUTTLES.forEach(shuttle => {
          shuttle.times.forEach(time => {
            const minutes = minutesUntilTodayTime(time);

            // solo mostrar cuando quede menos de 1h
            if (minutes > 0 && minutes <= 60) {
              results.push({
                line: shuttle.line,
                lineCode: shuttle.line,
                destination: shuttle.destination,
                minutes,
                isShuttle: true
              });
            }
          });
        });
      }


      // Ordenar por tiempo
      const sorted = results.sort((a, b) => a.minutes - b.minutes);

      // Limitar metro ligero a 3 llegadas
      const tramArrivals = sorted
        .filter(a => a.isTram && a.line === "ML3")
        .slice(0, 3);

      // Buses normales
      const busArrivals = sorted.filter(a => !a.isTram && !a.isShuttle);

      // Lanzaderas
      const shuttleArrivals = sorted.filter(a => a.isShuttle);

      const final = [...busArrivals, ...shuttleArrivals, ...tramArrivals]
        .sort((a, b) => a.minutes - b.minutes);
      return final;

    }

    // --- Cargar ubicación de buses con stopCode obligatorio ---
    async function loadBusLocations(lineCode) {
      const stopCode = LINE_STOPS[lineCode];
      if (!stopCode) return [];

      const url = `https://api.madridtransporte.com/lines/bus/${lineCode}/locations/2?stopCode=${stopCode}`;
      try {
        const res = await fetch(url);
        const data = await res.json();
        return data.locations || [];
      } catch (e) {
        return [];
      }
    }

    function createMap(container, locations) {
      const map = L.map(container).setView(
        [locations[0].coordinates.latitude, locations[0].coordinates.longitude],
        13
      );

      L.tileLayer("https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png", {
        attribution: "© OpenStreetMap"
      }).addTo(map);

      return map;
    }

    function renderBuses(map, markers, locations) {
      markers.forEach(m => m.remove());
      markers.length = 0;

      locations.forEach(bus => {
        const m = L.marker([bus.coordinates.latitude, bus.coordinates.longitude])
          .addTo(map)
          .bindPopup(`
          <strong>Bus ${bus.codVehicle}</strong><br>
          Servicio: ${bus.service || "—"}
        `);
        markers.push(m);
      });

      if (markers.length) {
        const group = L.featureGroup(markers);
        map.fitBounds(group.getBounds().pad(0.25));
      }
    }

    // --- Toggle mapa por línea ---
    async function toggleMap(btn) {
      const lineCode = btn.dataset.linecode;
      const container = document.getElementById(`map-${lineCode}`);

      if (container.classList.contains("d-none")) {
        container.classList.remove("d-none");
        btn.textContent = "Ocultar mapa";

        if (!maps[lineCode]) {
          const locations = await loadBusLocations(lineCode);
          if (!locations.length) {
            container.innerHTML = "<div class='p-3 text-small'>No hay buses en ruta</div>";
            return;
          }

          const map = createMap(container, locations);
          const markers = [];
          renderBuses(map, markers, locations);

          maps[lineCode] = { map, markers };
        }
      } else {
        container.classList.add("d-none");
        btn.textContent = "Ver ubicación (beta)";
      }
    }

    // --- Renderizar lista de llegadas ---
    function render(arrivals) {
      arrivalsEl.innerHTML = "";

      if (!arrivals.length) {
        arrivalsEl.innerHTML = "<li class='Box-row text-small color-fg-muted'>No hay servicios próximos</li>";
        return;
      }

      arrivals.forEach((a, idx) => {
        const li = document.createElement("li");
        li.className = "Box-row";

        li.innerHTML = `
		  <div class="d-flex flex-justify-between flex-items-center">
			<div>
			  <strong>${a.line}</strong>
			  <span class="color-fg-muted">→ ${a.destination}</span>
			</div>
			<div class="text-right">
			  <span class="Label Label--accent mr-2">${a.minutes} min</span>
			  ${(a.isTram || a.isShuttle) ? '' : `<button class="btn btn-sm btn-outline" data-linecode="${a.lineCode}">Ver ubicación (beta)</button>`}
			</div>
		  </div>
		  ${(a.isTram || a.isShuttle) ? '' : `<div id="map-${a.lineCode}" class="d-none mt-2" style="height: 300px; border-radius: 6px;"></div>`}
		`;

        arrivalsEl.appendChild(li);
      });
    }

    arrivalsEl.addEventListener("click", e => {
      if (e.target.tagName === "BUTTON") {
        toggleMap(e.target);
      }
    });

    async function refresh() {
      statusEl.textContent = "Actualizando…";
      const arrivals = await loadArrivals();
      render(arrivals);
      statusEl.textContent = "Actualizado " + new Date().toLocaleTimeString() + ". Es la API del CRTM, no va muy bien, rogamos comprensión. Las líneas no mostradas son por no recibir respuesta en la API.";
    }

    refresh();
    setInterval(refresh, 60000);
  })();
</script>
<script>
  async function verificarAtasco() {
    const avisoEl = document.getElementById('aviso-atasco');
    if (!avisoEl) return;

    try {
      const res = await fetch('https://notifierpushrss.onrender.com/api/m511');
      const data = await res.json();

      if (data.total_atascos === 0) {
        avisoEl.style.display = 'none';
        return;
      }

      // Prioridad de gravedad
      const prioridad = {
        'lowest': 1,
        'low': 2,
        'medium': 3,
        'high': 4,
        'highest': 5
      };

      // Buscar el atasco más grave
      const atasco = data.atascos.reduce((max, actual) => {
        return (prioridad[actual.gravedad] || 0) >
          (prioridad[max.gravedad] || 0)
          ? actual
          : max;
      }, data.atascos[0]);

      const nivelTexto = {
        'lowest': 'muy leve',
        'low': 'leve',
        'medium': 'medio',
        'high': 'grave',
        'highest': 'muy grave'
      }[atasco.gravedad] || atasco.nivel_gravedad;

      avisoEl.textContent = `Hay atasco ${nivelTexto} en Colonia Jardín.`;
      avisoEl.style.display = 'block';

    } catch (err) {
      avisoEl.style.display = 'none';
    }
  }

  document.addEventListener('DOMContentLoaded', () => {
    verificarAtasco();
    setInterval(verificarAtasco, 120000);
  });
</script>